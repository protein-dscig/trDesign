import numpy as np
import scipy
import scipy.spatial
import string
import tensorflow as tf

import pandas as pd
from pandas.api.types import CategoricalDtype

# from pyrosetta import *

# read A3M and convert letters into
# integers in the 0..20 range
def parse_a3m(filename):
    seqs = []
    table = str.maketrans(dict.fromkeys(string.ascii_lowercase))
    
    # read file line by line
    for line in open(filename,"r"):
        # skip labels
        if line[0] != '>':
            # remove lowercase letters and right whitespaces
            seqs.append(line.rstrip().translate(table))

    # convert letters into numbers
    # alphabet = np.array(list("ARNDCQEGHILKMFPSTWYV-"), dtype='|S1').view(np.uint8)
    alphabet = np.array(list("ARNDCQEGHILKMFPSTWYV*"), dtype='|S1').view(np.uint8)
    msa = np.array([list(s) for s in seqs], dtype='|S1').view(np.uint8)
    for i in range(alphabet.shape[0]):
        msa[msa == alphabet[i]] = i

    # treat all unknown characters as gaps
    msa[msa > 20] = 20

    return msa

# characters to integers
def aa2idx(seq):

    # convert letters into numbers
    # abc = np.array(list("ARNDCQEGHILKMFPSTWYV-"), dtype='|S1').view(np.uint8)
    abc = np.array(list("ARNDCQEGHILKMFPSTWYV*"), dtype='|S1').view(np.uint8)
    idx = np.array(list(seq), dtype='|S1').view(np.uint8)
    for i in range(abc.shape[0]):
        idx[idx == abc[i]] = i

    # treat all unknown characters as gaps
    idx[idx > 20] = 20

    return idx

# integers back to sequence:
def idx2aa(idx):
    # abc=np.array(list("ARNDCQEGHILKMFPSTWYV"))
    abc=np.array(list("ARNDCQEGHILKMFPSTWYV*"))
    return("".join(list(abc[idx])))

# 1-hot MSA to PSSM
def msa2pssm(msa1hot, w):
    beff = tf.reduce_sum(w)
    f_i = tf.reduce_sum(w[:,None,None]*msa1hot, axis=0) / beff + 1e-9
    h_i = tf.reduce_sum( -f_i * tf.log(f_i), axis=1)    
    return tf.concat([f_i, h_i[:,None]], axis=1)

# reweight MSA based on cutoff
def reweight(msa1hot, cutoff):
    with tf.name_scope('reweight'):
        id_min = tf.cast(tf.shape(msa1hot)[1], tf.float32) * cutoff
        id_mtx = tf.tensordot(msa1hot, msa1hot, [[1,2], [1,2]])
        id_mask = id_mtx > id_min
        w = 1.0/tf.reduce_sum(tf.cast(id_mask, dtype=tf.float32),-1)
    return w

def fast_dca(msa1hot, weights, penalty = 4.5):
    
    nr = tf.shape(msa1hot)[0]
    nc = tf.shape(msa1hot)[1]
    ns = tf.shape(msa1hot)[2]

    with tf.name_scope('covariance'):
        x = tf.reshape(msa1hot, (nr, nc * ns))
        num_points = tf.reduce_sum(weights) - tf.sqrt(tf.reduce_mean(weights))
        mean = tf.reduce_sum(x * weights[:,None], axis=0, keepdims=True) / num_points
        x = (x - mean) * tf.sqrt(weights[:,None])
        cov = tf.matmul(tf.transpose(x), x)/num_points

    with tf.name_scope('inv_convariance'):
        cov_reg = cov + tf.eye(nc * ns) * penalty / tf.sqrt(tf.reduce_sum(weights))
        inv_cov = tf.linalg.inv(cov_reg)

        x1 = tf.reshape(inv_cov,(nc, ns, nc, ns))
        x2 = tf.transpose(x1, [0,2,1,3])
        features = tf.reshape(x2, (nc, nc, ns * ns))

        x3 = tf.sqrt(tf.reduce_sum(tf.square(x1[:,:-1,:,:-1]),(1,3))) * (1-tf.eye(nc))
        apc = tf.reduce_sum(x3,0,keepdims=True) * tf.reduce_sum(x3,1,keepdims=True) / tf.reduce_sum(x3)
        contacts = (x3 - apc) * (1-tf.eye(nc))

    return tf.concat([features, contacts[:,:,None]], axis=2)


def get_dihedrals(a, b, c, d):

    b0 = -1.0*(b - a)
    b1 = c - b
    b2 = d - c

    b1 /= np.linalg.norm(b1, axis=-1)[:,None]

    v = b0 - np.sum(b0*b1, axis=-1)[:,None]*b1
    w = b2 - np.sum(b2*b1, axis=-1)[:,None]*b1

    x = np.sum(v*w, axis=-1)
    y = np.sum(np.cross(b1, v)*w, axis=-1)

    return np.arctan2(y, x)


def get_angles(a, b, c):

    v = a - b
    v /= np.linalg.norm(v, axis=-1)[:,None]

    w = c - b
    w /= np.linalg.norm(w, axis=-1)[:,None]

    x = np.sum(v*w, axis=1)

    return np.arccos(x)


def get_neighbors(pose, dmax):

    nres = pyrosetta.rosetta.core.pose.nres_protein(pose)

    # three anchor atoms
    N = np.stack([np.array(pose.residue(i).atom('N').xyz()) for i in range(1,nres+1)])
    Ca = np.stack([np.array(pose.residue(i).atom('CA').xyz()) for i in range(1,nres+1)])
    C = np.stack([np.array(pose.residue(i).atom('C').xyz()) for i in range(1,nres+1)])

    # recreate Cb given N,Ca,C
    b = Ca - N
    c = C - Ca
    a = np.cross(b, c)
    Cb = -0.58273431*a + 0.56802827*b - 0.54067466*c + Ca

    # fast neighbors search
    kdCb = scipy.spatial.cKDTree(Cb)
    indices = kdCb.query_ball_tree(kdCb, dmax)

    # indices of contacting residues
    idx = np.array([[i,j] for i in range(len(indices)) for j in indices[i] if i != j]).T
    idx0 = idx[0]
    idx1 = idx[1]

    # Cb-Cb distance matrix
    dist6d = np.zeros((nres, nres))
    dist6d[idx0,idx1] = np.linalg.norm(Cb[idx1]-Cb[idx0], axis=-1)

    # matrix of Ca-Cb-Cb-Ca dihedrals
    omega6d = np.zeros((nres, nres))
    omega6d[idx0,idx1] = get_dihedrals(Ca[idx0], Cb[idx0], Cb[idx1], Ca[idx1])

    # matrix of polar coord theta
    theta6d = np.zeros((nres, nres))
    theta6d[idx0,idx1] = get_dihedrals(N[idx0], Ca[idx0], Cb[idx0], Cb[idx1])

    # matrix of polar coord phi
    phi6d = np.zeros((nres, nres))
    phi6d[idx0,idx1] = get_angles(Ca[idx0], Cb[idx0], Cb[idx1])

    return dist6d, omega6d, theta6d, phi6d

def aa_to_idx(sequence, dic_dir='data/aa.csv'):
    '''
    Convert list of amino acid sequences to list of indices
    '''

    dic = pd.read_csv(dic_dir, sep=',')
    aa_idx = dict(zip(dic.iloc[0], dic.columns))
    indices_list = []
    if isinstance(sequence, str):
        sequence = [sequence]
    for seq in sequence:
        indices = []
        for aa in seq:
            indices.append(int(aa_idx[aa]))
        indices_list.append(indices)
    return indices_list

def idx_to_aa(indices_list, dic_dir='data/aa.csv'):
    '''
    Convert list of indices to list of amino acid sequences
    '''
    dic = pd.read_csv(dic_dir, sep=',')
    idx_aa = dict(zip(dic.columns, dic.iloc[0]))
    sequence_list = []
    for indices in indices_list:
        sequence = ""
        for idx in indices:
            sequence += idx_aa[str(idx)]
        sequence_list.append(sequence)
    return sequence_list

def idx_to_one_hot(indices, dic_dir='data/aa.csv'):
    '''
    Convert list of indices to one-hot encoded dataframe
    '''
    dic = pd.read_csv(dic_dir, sep=',').columns.tolist()
    dic = [int(i) for i in dic]
    df_type = CategoricalDtype(categories=dic, ordered=False)
    indices = np.array(indices)
    if len(indices.shape) == 1:
        one_hot = pd.DataFrame(indices).transpose().astype(df_type)
    else:
        one_hot = pd.DataFrame(indices).astype(df_type)
    one_hot = pd.get_dummies(one_hot)
    return one_hot
    
def aa_to_one_hot(sequence, dic_dir='data/aa.csv'):
    '''
    Convert list of amino acid sequences to one-hot encoded dataframe
    '''
    indices = aa_to_idx(sequence=sequence, dic_dir=dic_dir)
    return idx_to_one_hot(indices, dic_dir)
